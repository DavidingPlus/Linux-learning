    #include <sys/shm.h>

    int shmget(key_t key, size_t size, int shmflg);
作用：创建一个新的共享内存段或者获取一个既有的共享内存段的标识
    新创建的内存段中的数据都会被初始化为0
参数：
    key：key_t类型，是一个整形，通过这个找到或者创建一个共享内存
        一般用16进制表示，并且是非0值，创建的时候可以随便给，给一个16进制的数或者10进制(会转化)，找到的时候按照创建时候匹配就行
    size：size_t类型，共享内存的大小，会自动调整为分页边界的整数倍(和内存映射是一样的)
    shmflg：
        共享内存的属性：用按位或连接
            - 访问权限
            - 附加属性(创建共享内存，判断共享内存是否存在，获取共享内存)

                创建：IPC_CREAT 加上 访问权限(比如0664)
                获取：IPC_CREAT(不加访问权限)
                判断：IPC_EXCL，需要和IPC_CREAT一起使用，用按位或连接
返回值：
    成功 >0 返回共享内存引用的ID，后面操作共享内存使用这个标识
    失败 -1.修改errno

    void *shmat(int shmid, const void *_Nullable shmaddr, int shmflg);
作用：和当前的进程进行关联
参数：
    shmid：共享内存的标识，ID，由shmget()返回值获取
    shmaddr：申请的共享内存的起始地址，指定为nullptr，让系统帮我们去分配
    shmflg：
        对共享内存的操作
            - 读：SHM_RDONLY，而且必须要有读权限
            - 读写：0，我们指定什么都不给，但是由于必须有读权限，系统会给我们加上读写的权限
返回值：
    成功 返回共享内存的起始地址
    失败 (void*)-1


    int shmdt(const void *shmaddr);
作用：解除当前进程和共享内存的关联
参数：
    shmaddr：共享内存的首地址
返回值：
    成功 0
    失败 -1，修改errno

    int shmctl(int shmid, int cmd, struct shmid_ds *buf);
作用：对共享内存进行操作，比如可以删除，共享内存要删除才会消失；创建共享内存的进程被销毁了对这块共享内存没有任何影响，必须要手动删除才行
参数：
    shmid：共享内存的id
    cmd：要做的操作
        IPC_STAT：获取共享内存当前的状态
        IPC_SET：设置共享内存的状态
        IPC_RMID：标记共享内存被销毁，之所以是标记是因为有很多个进程都连接了这个共享内存，我这一个进程并不能想删除就删除，而只是标记下来，当检测到连接数为0时，系统自会将这块共享内存删除
    buf：需要设置或者获取的共享内存的属性信息
        IPC_STAT：buf存储数据
        IPC_SET：buf中需要初始化数据，设置到内核中
        IPC_RMID：没有用，传递nullptr即可


    #include <sys/ipc.h>

    key_t ftok(const char *pathname, int proj_id);
作用：根据指定的路径名和int值，生成一个共享内存的key，我们可以不用自己指定
参数：
    pathname：指定一个存在的路径
    proj_id：int类型的值，但是这系统调用只会使用其中的一个字节(8位)
        返回：0-255，一般指定一个字符 'a'

问题1：操作系统如何知道一块共享内存被多少个进程关联？
    - 共享内存维护了一个结构体 struct shmid_ds 这个结构体中有一个成员 shm_nattach
    - shm_nattach记录了关联的进程个数

问题2：可以不可以对共享内存多次删除 stmctl()
    - 可以，因为shmctl()只是标记删除共享内存，不是直接删除
    - 什么时候真正删除，当和共享内存关联的进程数为0的时候，就真正被删除
    - 当共享内存的key为0的时候，表示共享内存被标记删除，如果进程取消关联就不能继续操作这个共享内存，这种情况下也不能再次关联

问题3：共享内存和内存映射的区别
    - 共享内存可以直接创建，内存映射需要磁盘文件(匿名映射除外)
    - 共享内存效率更高
    - 内存：
        共享内存：所有的进程操作的是同一块共享内存
        内存映射：(父子进程除外)每个进程在自己的虚拟地址空间中有一个独立的内存
    - 数据安全
        - 进程突然退出，共享内存还存在，内存映射消失了
        - 运行进程的电脑死机了，数据存储在共享内存中就没有了，内存映射区的数据也没有了，但是他的数据已经同步给磁盘了
    - 生命周期
        - 内存映射区：进程退出，内存映射区销毁
        - 共享内存：进程退出，共享内存还在，标记删除(所有关联的进程数为0)，或者关机
            如果进程退出，系统会自动和共享内存取消关联
